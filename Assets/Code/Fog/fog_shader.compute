// ALL modified from https://blog.maximeheckel.com/posts/real-time-cloudscapes-with-volumetric-raymarching/

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
sampler2D  BlueNoise;
// RWStructuredBuffer<float2> gradients;


float3 _CamPlane;
float4x4 _CamToWorldMatrix;
float time;

int num_steps;
float step_size;
float cloud_density;
float distance_falloff_factor;

float3 disk_normal;
float2 ring_size;

float3 light_loc;
float max_light_step;
float light_step_size;
float anisotropic_scatter_factor;

float4 colour_max;
float4 colour_min;
float interpolation_factor;

struct Ray {
    float3 dir;
    float3 pos;
};


// noise
// Volume raycasting by XT95
// https://www.shadertoy.com/view/lss3zr

// Taken from cloud demo: https://www.shadertoy.com/view/WdXGRj
float3x3 m = float3x3( 0.00,  0.80,  0.60,
              -0.80,  0.36, -0.48,
              -0.60, -0.48,  0.64 );
float hash( float n )
{
    return frac(sin(n)*43758.5453);
}

float noise(  float3 x )
{
    float3 p = floor(x);
    float3 f = frac(x);

    f = f*f*(3.0-2.0*f);

    float n = p.x + p.y*57.0 + 113.0*p.z;

    float res = lerp(lerp(lerp( hash(n+  0.0), hash(n+  1.0),f.x),
                        lerp( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
                    lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
    return res;
}

/////////////////////////////////////

// Taken from FBM https://blog.maximeheckel.com/posts/real-time-cloudscapes-with-volumetric-raymarching/
float fbm( float3 p )
{
    float3 q = p + time * 0.5 * float3(1.0, -0.2, -1.0);
    float g = noise(q);

    float f = 0.0;
    float scale = 0.5;
    float factor = 2.02;

    for (int i = 0; i < 6; i++) {
        f += scale * noise(q);
        q *= factor;
        factor += 0.21;
        scale *= 0.5;
    }

    return f;
}

// Colour interpolation
float3 exponential_interpolation(float3 col_min, float3 col_max, float value){

    value = saturate(value);
    float denom = max(1.0 - exp(-interpolation_factor), 1e-6);
    float factor = (1.0 - exp(-interpolation_factor * value)) / (denom);  

    return lerp(col_min, col_max, factor);
}

// Light phase function to model Anisotropic 
float HenyeyGreenstein(float g, float mu) {
  float gg = g * g;
	return (1.0 / (4.0 * 3.14))  * ((1.0 - gg) / pow(1.0 + gg - 2.0 * g * mu, 1.5));
}

float BeersLaw (float dist, float absorption) {
  return exp(-dist * absorption);
}


float signed_distance_field_sphere(float3 pos){
    return length(pos - float3(0,0,0)) - 5.0f;
}

float signed_distance_cloud(float3 pos){

    float2 d = abs(float2(length(pos.xz),pos.y)) - ring_size;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float scene(float3 pos){
    float distance = signed_distance_cloud(pos);
    float f = fbm(pos);

    return -distance + f;
}

// Ray march from cloud to light source
float lightmarch(float3 position, float dist) {
  float light_dir = normalize(light_loc);
  float total_density = 0.0;
  float depth = 0.0f;

  for (int step = 0; step < max_light_step; step++) {
      float3 pos = position + depth * light_dir;

      float light_sample = scene(pos);
      total_density += light_sample;

      depth += light_step_size;
  }

  float transmittance = BeersLaw(total_density, cloud_density);
  return transmittance;
}


float4 Trace(Ray ray, float offset){
    float total_transmittance = 1.0f;
    float light_intensity = 0.0f;

    float depth = 0.0f;

    float phase = HenyeyGreenstein(anisotropic_scatter_factor, dot(ray.dir, normalize(light_loc)));


    for(int i = 0; i < num_steps; i++){


        float3 pos = ray.pos + depth * ray.dir ;
        float density = scene(pos);

        

        if (density > 0.0f){
            float lightTransmittance = lightmarch(pos, density);
            float luminance = 0.02 + density *phase;

            total_transmittance *= lightTransmittance;
            light_intensity += total_transmittance * luminance;
        }


        depth += step_size * offset;

    }

    // if (light_intensity > 0) {
    //     return float4(exponential_interpolation(colour_max, colour_min, light_intensity), light_intensity );
    // }
    return light_intensity;
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width,height;
    Result.GetDimensions(width, height);

    float2 uv = id.xy / float2(width,height);

    float2 noiseUV = frac(id.xy / 1024.0); 
    float blueNoise = tex2Dlod(BlueNoise, float4(noiseUV, 0, 0)).r ;
    float offset = frac(blueNoise );


    // Ray marching
    Ray ray;
    float3 totalIncomingLight = 0;

    float3 focusPointLocal = float3((uv - 0.5), 1) * _CamPlane;
    float3 focusPoint = mul(_CamToWorldMatrix, float4(focusPointLocal, 1));
    float3 camRight = _CamToWorldMatrix._m00_m10_m20;
    float3 camUp = _CamToWorldMatrix._m01_m11_m21;


    ray.pos = mul(_CamToWorldMatrix, float4(0,0,0,1)).xyz;
    ray.dir = normalize(focusPoint - ray.pos);

    Result[id.xy] = Trace(ray, offset);
}
