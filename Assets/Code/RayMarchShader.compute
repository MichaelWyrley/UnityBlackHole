// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
sampler2D  BlueNoise;

// static const float speed_of_light = 299792458f;
// static const float G = 0.000000000066743f;
static const float c = 1.0f;
static const float G = 1.0f;

float dt;
float time;
float change_size;
float cloud_density;
float radius;
float mass;
float2 ring_size;

float3 disk_normal;
int num_steps;
float3 _CamPlane;
float4x4 _CamToWorldMatrix;

// Cloud

float3 light_loc;
int fog_step_size;
float interpolation_factor;
float4 colour_max;
float4 colour_min;


struct Ray {
    float3 dir;
    float3 pos;

    float r;
    float phi;
    float theta;

    float dr;
    float dphi;
    float dtheta;

    float E, L;             // conserved quantities
};

struct GeodesicUpdate {
    float dr;
    float dtheta;
    float dphi;

    float dr_dr;
    float dtheta_dtheta;
    float dphi_dphi;
};

/*

Black Hole Code

*/

void  calculatePolar(inout Ray ray) 
{
    ray.r = sqrt(ray.pos.x * ray.pos.x + ray.pos.y * ray.pos.y + ray.pos.z*ray.pos.z);
    ray.theta = acos(ray.pos.z / ray.r); 
    ray.phi = atan2(ray.pos.y, ray.pos.x);

    float dx = ray.dir.x; 
    float dy = ray.dir.y; 
    float dz = ray.dir.z;

    ray.dr     = sin(ray.theta)*cos(ray.phi)*dx + sin(ray.theta)*sin(ray.phi)*dy + cos(ray.theta)*dz;
    ray.dtheta = cos(ray.theta)*cos(ray.phi)*dx + cos(ray.theta)*sin(ray.phi)*dy - sin(ray.theta)*dz;
    ray.dtheta /= ray.r;
    ray.dphi   = -sin(ray.phi)*dx + cos(ray.phi)*dy;
    ray.dphi  /= (ray.r * sin(ray.theta));

    // Calculate angular momentum and energy
    ray.L = ray.r * ray.r * sin(ray.theta) * ray.dphi;
    float f = 1.0f - radius / ray.r;
    float dt_dlambda = sqrt((ray.dr*ray.dr)/f 
                + ray.r * ray.r * ray.dtheta * ray.dtheta 
                + ray.r * ray.r * sin(ray.theta) * sin(ray.theta) * ray.dphi * ray.dphi);
    ray.E = f * dt_dlambda;
}

float3 calculateCartesian(float r, float theta, float phi) {
    return float3(r * sin(theta) *cos(phi), r * sin(theta) * sin(phi), r * cos(theta));
}

GeodesicUpdate geodesic(Ray ray) {

    float f = 1.0f - radius / ray.r;
    float dt_dlambda = ray.E / f;

    GeodesicUpdate geodesic_update;

    geodesic_update.dr = ray.dr;
    geodesic_update.dtheta = ray.dtheta;
    geodesic_update.dphi = ray.dphi;

    // Second derivatives (from 3D Schwarzschild null geodesics):
    geodesic_update.dr_dr = 
        - (radius / (2 * ray.r * ray.r)) * f * dt_dlambda * dt_dlambda
        + (radius / (2 * ray.r * ray.r * f)) * ray.dr * ray.dr
        + ray.r * f * (ray.dtheta * ray.dtheta + sin(ray.theta) * sin(ray.theta) * ray.dphi * ray.dphi);

    geodesic_update.dtheta_dtheta = 
        - (2.0 / ray.r) * ray.dr * ray.dtheta
        + sin(ray.theta) * cos(ray.theta) * ray.dphi * ray.dphi;

    geodesic_update.dphi_dphi = 
        - (2.0 / ray.r) * ray.dr * ray.dphi
        - 2.0 * cos(ray.theta) / sin(ray.theta) * ray.dtheta * ray.dphi;

    return geodesic_update;
}

Ray update_state(Ray ray, GeodesicUpdate g, float multiplyer) {

    Ray new_ray;
    new_ray.pos = ray.pos;
    new_ray.dir = ray.dir;
    new_ray.E = ray.E;
    new_ray.L = ray.L;  

    new_ray.r = ray.r + g.dr *multiplyer;
    new_ray.phi = ray.phi + g.dphi *multiplyer;
    new_ray.theta = ray.theta + g.dtheta *multiplyer;

    new_ray.dr = ray.dr + g.dr_dr *multiplyer;
    new_ray.dphi = ray.dphi + g.dphi_dphi *multiplyer;
    new_ray.dtheta = ray.dtheta + g.dtheta_dtheta *multiplyer;

    return new_ray;
}

void rk4(inout Ray ray, float dlambda){

    GeodesicUpdate k1 = geodesic(ray);
    Ray ray_2 = update_state(ray, k1, dlambda / 2.0f);
    
    GeodesicUpdate k2 = geodesic(ray_2);
    Ray ray_3 = update_state(ray, k2, dlambda / 2.0f);

    GeodesicUpdate k3 = geodesic(ray_3);
    Ray ray_4 = update_state(ray, k3, dlambda / 2.0f);

    GeodesicUpdate k4 = geodesic(ray_4);

    ray.r += (dlambda/6.0f)*(k1.dr + 2*k2.dr + 2*k3.dr + k4.dr);
    ray.phi += (dlambda/6.0f)*(k1.dphi + 2*k2.dphi + 2*k3.dphi + k4.dphi);
    ray.theta += (dlambda/6.0f)*(k1.dtheta + 2*k2.dtheta + 2*k3.dtheta + k4.dtheta);

    ray.dr += (dlambda/6.0f)*(k1.dr_dr + 2*k2.dr_dr + 2*k3.dr_dr + k4.dr_dr);
    ray.dphi += (dlambda/6.0f)*(k1.dphi_dphi + 2*k2.dphi_dphi + 2*k3.dphi_dphi + k4.dphi_dphi);
    ray.dtheta += (dlambda/6.0f)*(k1.dtheta_dtheta + 2*k2.dtheta_dtheta + 2*k3.dtheta_dtheta + k4.dtheta_dtheta);
}

////////////////////

/*

Fog Code

*/

// noise
// Volume raycasting by XT95
// https://www.shadertoy.com/view/lss3zr

// Taken from cloud demo: https://www.shadertoy.com/view/WdXGRj
float3x3 m = float3x3( 0.00,  0.80,  0.60,
              -0.80,  0.36, -0.48,
              -0.60, -0.48,  0.64 );
float hash( float n )
{
    return frac(sin(n)*43758.5453);
}

float noise(  float3 x )
{
    float3 p = floor(x);
    float3 f = frac(x);

    f = f*f*(3.0-2.0*f);

    float n = p.x + p.y*57.0 + 113.0*p.z;

    float res = lerp(lerp(lerp( hash(n+  0.0), hash(n+  1.0),f.x),
                        lerp( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
                    lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
    return res;
}

/////////////////////////////////////

// Taken from FBM https://blog.maximeheckel.com/posts/real-time-cloudscapes-with-volumetric-raymarching/
float fbm( float3 p )
{
    float3 q = p + time * 0.5 * float3(1.0, -0.2, -1.0);
    float g = noise(q);

    float f = 0.0;
    float scale = 0.5;
    float factor = 2.02;

    for (int i = 0; i < 6; i++) {
        f += scale * noise(q);
        q *= factor;
        factor += 0.21;
        scale *= 0.5;
    }

    return f;
}



float3 exponential_interpolation(float3 col_min, float3 col_max, float value){

    value = saturate(value);
    float denom = max(1.0 - exp(-interpolation_factor), 1e-6);
    float factor = (1.0 - exp(-interpolation_factor * value)) / (denom);  

    return lerp(col_min, col_max, factor);

}

float signed_distance_cloud(float3 pos){

    float inner_size = ring_size.x * radius;
    float outer_size = ring_size.y * radius;
    float plane = dot(pos,disk_normal) + 0.01f;

    float inner_disk = max(plane, -(length(pos)-inner_size));
    float outer_dist = max(inner_disk, length(pos)- outer_size);

    return outer_dist;
}

float cloud_scene(float3 pos){
    float distance = signed_distance_cloud(pos);
    float f = fbm(pos);

    return -distance + f;
}

//////////////////////////////////////////////////////////////////////

float signed_distance_black_hole(float3 pos){

    return sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z) - radius;

}

float signed_distance_field_sphere(float3 pos){
    return length(pos - float3(0,0,20.0)) - 8.0f;
}





float4 Trace(Ray ray, float offset){

    float4 res = float4(0.0f,0.0f,0.0f, 0.0f);
    float depth = 0.0f;

    float dlambda = change_size;
    
    int fog_ratio = (int)(num_steps / fog_step_size);

    for(int i = 0; i < num_steps; i++){

        rk4(ray,dlambda);

        float3 pos = calculateCartesian(ray.r, ray.theta, ray.phi);

        if (signed_distance_black_hole(pos) < 0){
            return float4(0,0,0,0);
        }
        if(i % fog_ratio == 0){
            float density = cloud_scene(pos);
            if (density > 0.0f){
                float diffuse = clamp((cloud_scene(pos+0.001f*light_loc)-density)/0.001f,0.0,1.0) ;

                float3 lin = float3(0.60,0.60,0.75) * 1.1 + 0.8 * float3(1.0,0.6,0.3) * diffuse;
                float4 color = float4(exponential_interpolation(colour_min.rgb, colour_max.rgb, density), density );
                color.rgb *= lin;

                color.rgb *= color.a;
                res += color * (1.0 - res.a);

                if (res.a < 0.0001 || res.a > 0.9999){
                    break;
            }
        }

        }

        


    }
    return res;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width,height;
    Result.GetDimensions(width, height);

    float2 uv = id.xy / float2(width,height);

    float2 noiseUV = frac(id.xy / 1024.0); 
    float blueNoise = tex2Dlod(BlueNoise, float4(noiseUV, 0, 0)).r ;
    float offset = frac(blueNoise );

    // Ray marching
    Ray ray;

    float3 focusPointLocal = float3((uv - 0.5), 1) * _CamPlane;
    float3 focusPoint = mul(_CamToWorldMatrix, float4(focusPointLocal, 1));
    float3 camRight = _CamToWorldMatrix._m00_m10_m20;
    float3 camUp = _CamToWorldMatrix._m01_m11_m21;


    ray.pos = mul(_CamToWorldMatrix, float4(0,0,0,1)).xyz;
    ray.dir = normalize(focusPoint - ray.pos);
    calculatePolar(ray);

    Result[id.xy] = Trace(ray, offset);
}
